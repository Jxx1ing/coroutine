<!DOCTYPE html>
<html>
<head>
<title>协程的实现与原理</title>
<meta charset = "utf-8"/>
<style>body{margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',Heiti,sans-serif,SimSun,serif}ul{list-style:disc outside; padding-bottom: 4px;}li{line-height: 27px; list-style: disc;font-size:19px;padding: 2px 0px;}blockquote p {color: #252525;font-family: 'EB Garamond', serif;font-size: 24px;}blockquote {background-color: #dce7e7 !important;border-left: 5px solid #219895 !important;margin: 2px 0 !important;padding: 1px 0px 1px 0px;}img{max-width:1024px;padding: 5px 0px;}.annot{padding: 15px 0px;border-bottom-style:solid;}.tag{color:blue;font-size:15px;}</style></head>
<body>
<div style="font-size: 22px; padding: 0 15px 0; ">
<div style = "padding-bottom: 0px"><h2>协程的实现与原理</h2></div>
<div style = "background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div>
</div>
<ul><li><blockquote><p>吞吐量是 IO 处理时间加上业务处理 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=0&x=195&y=517&id=10&uuid=45efe38c46a6f83f06b9d4e56683013d>[P0]</a></p></blockquote></li><li><blockquote><p>心跳包 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=0&x=336&y=533&id=11&uuid=93ad01c3308c56a6b15df7fe30ec96ec>[P0]</a></p></blockquote><div class="annot">客户端定期发送给服务器的消息，用来证明自己还活着。<br/>如果服务器超时没收到心跳包，服务器就认为客户端掉线</div></li><li><blockquote><p>业务处理时长等于 IO 读取（RECV 系统调用）加上业务处理（更新客户状态）。吞吐量等于1s 业务处理次数。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=0&x=296&y=564&id=12&uuid=fd7ae4f38dd8cec6190a8b4b20e8a622>[P0]</a></p></blockquote></li><li><blockquote><p>handle(sockfd); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=196&y=362&id=17&uuid=2ad26c09da4ec66aeee28142d1258582>[P1]</a></p></blockquote></li><li><blockquote><p>Handle(sockfd)实现方式有两种 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=333&y=470&id=18&uuid=8b938eafe3c00b646e773097febabe3b>[P1]</a></p></blockquote></li><li><blockquote><p>第一种，handle(sockfd)函数内部对 sockfd 进行读写动作 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=243&y=501&id=19&uuid=f7ef582f92b892ed2463eadfe7dadf09>[P1]</a></p></blockquote></li><li><blockquote><p>epoll_wait <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=215&y=128&id=20&uuid=61cbd44fde4d6e421c552945e0899f2b>[P1]</a></p></blockquote></li><li><blockquote><p>handle 的 io 操作（send,recv）与 epoll_wait 是在同一个处理流程里面的。这就是 IO 同步操作。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=293&y=680&id=21&uuid=6455b8ef6409a882fb5fff90fc3530eb>[P1]</a></p></blockquote></li><li><blockquote><p>对于响应式服务器，所有的客户端的操作驱动都是来源于这个大循环。来源于epoll_wait 的反馈结果。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=1&x=294&y=446&id=22&uuid=99dde3de10e369b75b41d18d6d6c2e96>[P1]</a></p></blockquote></li><li><blockquote><p>第二种，handle(sockfd)函数内部将 sockfd 的操作，push 到线程池中 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=2&x=275&y=127&id=23&uuid=a8954e15afd02e3c546d868747063668>[P2]</a></p></blockquote></li><li><blockquote><p>push_thread(sockfd, thread_cb); //将 sockfd 放到其他线程中运行。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=2&x=287&y=331&id=24&uuid=d9957f570befe82f9afd63237dd4b70f>[P2]</a></p></blockquote></li><li><blockquote><p>将 io 操作（recv，send）与 epoll_wait 不在一个处理流程里面，使得 io操作（recv,send）与 epoll_wait 实现解耦。这就叫做 IO 异步操作。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=2&x=297&y=400&id=28&uuid=ce1455a3b3c7e1ebc511205bef3a7780>[P2]</a></p></blockquote></li><li><blockquote><p>上文有提到 IO 同步操作，程序响应慢，IO 异步操作，程序响应快。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=2&x=269&y=532&id=29&uuid=e3a91ff46f5711a292425039566c85a0>[P2]</a></p></blockquote></li><li><blockquote><p>Handle 函数是将 sockfd 处理方式放到另一个已经其他的线程中运行 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=2&x=269&y=376&id=30&uuid=d8982c4ecff9dd2bc7c7c424e330b42f>[P2]</a></p></blockquote></li><li><blockquote><p>每次 accept 返回的时候，就为新来的客户端分配一个线程，这样一个客户端对应一个线程。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=293&y=163&id=31&uuid=641642ddac473202591833552bfad63b>[P5]</a></p></blockquote></li><li><blockquote><p>pthread_create(&thread_id, NULL, client_cb, &clientfd); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=270&y=312&id=32&uuid=4124d247fe04946e31186cc9eb266b62>[P5]</a></p></blockquote></li><li><blockquote><p>nty_coroutine_create(&read_co, server_reader, &cli_fd); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=272&y=531&id=36&uuid=f9584bb4e4781bd12ad4e67afa7191b8>[P5]</a></p></blockquote></li><li><blockquote><p>NtyCo 封装出来了若干接口，一类是协程本身的，二类是 posix 的异步封装 协程 API <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=290&y=678&id=37&uuid=33d61a69bbd001803af009efe38cd41b>[P5]</a></p></blockquote></li><li><blockquote><p>1. 协程创建 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=123&y=701&id=38&uuid=09228413256c9f4b58c18bbe1261ad3c>[P5]</a></p></blockquote></li><li><blockquote><p>2. 协程调度器的运行 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=5&x=147&y=748&id=39&uuid=be80eb3498daff6ab31f80a1e2e3fa0f>[P5]</a></p></blockquote></li><li><blockquote><p>POSIX 异步封装 API <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=141&y=95&id=40&uuid=d9919aaf364376c34bfad4f357a66e6d>[P6]</a></p></blockquote></li><li><blockquote><p>接口格式与 POSIX 标准的函数定义一致。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=198&y=189&id=41&uuid=ad38d59e592232c4aea577904c4e9e42>[P6]</a></p></blockquote></li><li><blockquote><p>第一个协程的创建；第二个 IO 异步操作；第三个协程子过程回调 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=297&y=441&id=42&uuid=57eb4f63408081e75fee32dc720ec14b>[P6]</a></p></blockquote></li><li><blockquote><p>int nty_coroutine_create(nty_coroutine **new_co, proc_coroutine func, void *arg) <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=292&y=593&id=43&uuid=f91ea3fe487b36afa5ffec13a4a52640>[P6]</a></p></blockquote></li><li><blockquote><p>参数 1：nty_coroutine **new_co <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=194&y=615&id=44&uuid=158be404844c47ee415ce3fcac15c0d5>[P6]</a></p></blockquote></li><li><blockquote><p>参数 2：proc_coroutine func <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=186&y=647&id=45&uuid=1f2f82fd494cfd0895f298e3f773fcd7>[P6]</a></p></blockquote></li><li><blockquote><p>参数 3：void *arg <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=157&y=678&id=46&uuid=9a53c95029e672e6fa1f1bc530fdf11d>[P6]</a></p></blockquote></li><li><blockquote><p>在函数返回的时候，会返回一个内部创建的协程对象 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=274&y=631&id=47&uuid=c65dee03fa05ef3ad5dc4ec994ab8b71>[P6]</a></p></blockquote></li><li><blockquote><p>传入空的协程的对象 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=356&y=615&id=48&uuid=ef25c7adee251bcbd4a2a3effc78ac02>[P6]</a></p></blockquote></li><li><blockquote><p>协程不存在亲属关系，都是一致的调度关系，接受调度器的调度。调用 create API就会创建一个新协程，新协程就会加入到调度器的就绪队列中。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=6&x=293&y=701&id=51&uuid=7a7ebec05fbddbe9c6ab8d28f5e353c6>[P6]</a></p></blockquote></li><li><blockquote><p>epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=7&x=283&y=437&id=52&uuid=6bf01b3b25c19b3cc88b649147acc48a>[P7]</a></p></blockquote></li><li><blockquote><p>在进行 IO 操作（recv，send）之前，先执行了 epoll_ctl 的 del 操作，将相应的 sockfd 从 epfd中删除掉，在执行完 IO 操作（recv，send）再进行 epoll_ctl 的 add 的动作。这段代码看起来似乎好像没有什么作用。  如果是在多个上下文中，这样的做法就很有意义了。能够保证 sockfd 只在一个上下文中能够操作 IO 的。不会出现在多个上下文同时对一个 IO 进行操作的。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=7&x=298&y=639&id=53&uuid=f11f70b0f148eee2c050988dc59b5b16>[P7]</a></p></blockquote></li><li><blockquote><p>把单一协程的工作与调度器的工作的划分清楚 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=7&x=216&y=717&id=54&uuid=1644f9d7a5b916e2792ed9dc9f23ae70>[P7]</a></p></blockquote></li><li><blockquote><p>yield 就是让出运行，resume就是恢复运行 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=7&x=298&y=740&id=55&uuid=81bbe4933e576fb0225282f6110e7695>[P7]</a></p></blockquote></li><li><blockquote><p>调度器与协程的上下文切换 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=7&x=227&y=748&id=56&uuid=39cc3241bfef7d790286457acea9d9a3>[P7]</a></p></blockquote></li><li><blockquote><p>在协程的上下文 IO 异步操作（nty_recv，nty_send）函数 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=8&x=220&y=314&id=58&uuid=575fdeb24026a70832cc7d7e1cf55e2e>[P8]</a></p></blockquote><div class="annot">图片源码：（参考nty_server.c的调用流程）<br/>nty_recv<br/>nty_send<br/>nty_poll_inner</div><div class="annot"><img src = "笔记大纲_协程的实现与原理/4c1de60da8f27b706b1fedef5bcc2851.png"></div></li><li><blockquote><p>yield <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=8&x=289&y=346&id=60&uuid=a2acefda8b392d558fc85c57f00ce096>[P8]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">图片源码：（参考nty_server.c的调用流程）</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">nty_corotine_yield</p></body></div><div class="annot"><img src = "笔记大纲_协程的实现与原理/9fd9da284347d60f51bfbd2c1bd475e7.png"></div></li><li><blockquote><p>Resume <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=8&x=272&y=362&id=61&uuid=f85bc048671ac774d80754ef1d6beb4f>[P8]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">图片源码：（参考nty_server.c的调用流程）</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">nty_coroutine_resume</p></body></div><div class="annot"><img src = "笔记大纲_协程的实现与原理/e8807743e0d76fabc1fccddc5e531104.png"></div></li><li><blockquote><p>%rax 作为函数返回值使用的。 %rsp 栈指针寄存器，指向栈顶 %rdi, %rsi, %rdx, %rcx, %r8, %r9 用作函数参数，依次对应第 1 参数，第 2 参数。。。 %rbx, %rbp, %r12, %r13, %r14, %r15 用作数据存储 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=8&x=301&y=739&id=63&uuid=8cee3bdfa8457212aa9878d2f0978635>[P8]</a></p></blockquote></li><li><blockquote><p>%r10, %r11 用作数据存储 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=153&y=97&id=64&uuid=6494ef16f25b887512c3517c86c48bd8>[P9]</a></p></blockquote></li><li><blockquote><p> EIP，用来存储 CPU 运行下一条指令的地址 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=298&y=134&id=65&uuid=d0bcc537abd63a7aa0679e799c4bef38>[P9]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">EIP</span> 是 x86 架构（32 位）里的 <span style=" font-weight:600;">指令指针寄存器 （不属于通用寄存器）</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Courier New';">%RIP</span> 是64 位的</p></body></div></li><li><blockquote><p>回调协程的子过程 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=8&x=195&y=600&id=66&uuid=e19d20258da5faa2be6222b6691123ed>[P8]</a></p></blockquote></li><li><blockquote><p>回调函数的地址存储到 EIP 中，将相应的参数存储到相应的参数寄存器中 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=298&y=150&id=67&uuid=eeea5e7b041a8f51358cc65add4b4b86>[P9]</a></p></blockquote></li><li><blockquote><p>co->func(co->arg); //子过程的回调函数 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=214&y=206&id=68&uuid=6aa03edf175696d1dad5826e397f0a35>[P9]</a></p></blockquote></li><li><blockquote><p>ty_coroutine_init <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=174&y=252&id=70&uuid=2cc5cac5a31fb0e6c60105306674bdb2>[P9]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">这份文档使用的是<span style=" font-size:large; font-weight:696; color:#0f1115;">非</span><span style=" font-size:large; font-weight:696; color:#0f1115;">ucontext库，即手动汇编方法（不使用ucontext）</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">但推荐使用ucontext库（更简单,NtyCo库2种方法都实现）</p></body></div></li><li><blockquote><p>co->ctx.edi = (void*)co; //设置参数 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=210&y=284&id=71&uuid=9fd1f775b97dbd3a716a23970e344dc6>[P9]</a></p></blockquote></li><li><blockquote><p>co->ctx.eip = (void*)_exec; //设置回调函数入口 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=240&y=299&id=72&uuid=00ab315f54e78e34a18ea87a6bb56784>[P9]</a></p></blockquote></li><li><blockquote><p>调用子函数之前要备份它，以防它被修改 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=295&y=80&id=73&uuid=b0bed3eef2874b9a18ae456075687ddd>[P9]</a></p></blockquote></li><li><blockquote><p>create, resume, yield <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=300&y=465&id=75&uuid=99509fdb43d23640632396052999ef5a>[P9]</a></p></blockquote></li><li><blockquote><p>没有 exit？以 NtyCo 为例，协程一旦创建就不能有用户自己销毁，必须得以子过程执行结束，就会自动销毁协程的上下文数据。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=290&y=489&id=76&uuid=931289d83c467119f6785e48b54698b7>[P9]</a></p></blockquote></li><li><blockquote><p>create：创建一个协程。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=179&y=560&id=77&uuid=2c2ffd9701e9e442a174f23e9e162c24>[P9]</a></p></blockquote></li><li><blockquote><p>调度器作为全局的单例。将调度器的实例存储在线程的私有空间 pthread_setspecific。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=324&y=582&id=78&uuid=859eb2669f3d6fcf3b19f2b2fc91f2c8>[P9]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">相关的类型/函数</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Monaspace Neon','ui-monospace','SFMono-Regular','SF Mono','Menlo','Consolas','Liberation Mono','monospace','Comic Sans MS'; font-size:12px; color:#1f2328; background-color:#ffffff;">pthread_key_t global_sched_key</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Monaspace Neon','ui-monospace','SFMono-Regular','SF Mono','Menlo','Consolas','Liberation Mono','monospace','Comic Sans MS'; font-size:12px; color:#1f2328; background-color:#fff8c5;">pthread_setspecific</span><span style=" font-family:'Monaspace Neon','ui-monospace','SFMono-Regular','SF Mono','Menlo','Consolas','Liberation Mono','monospace','Comic Sans MS'; font-size:12px; color:#1f2328; background-color:#ffffff;">(global_sched_key, sched)</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Monaspace Neon','ui-monospace','SFMono-Regular','SF Mono','Menlo','Consolas','Liberation Mono','monospace','Comic Sans MS'; font-size:12px; color:#1f2328; background-color:#fff8c5;">pthread_getspecific</span><span style=" font-family:'Monaspace Neon','ui-monospace','SFMono-Regular','SF Mono','Menlo','Consolas','Liberation Mono','monospace','Comic Sans MS'; font-size:12px; color:#1f2328; background-color:#ffffff;">(global_sched_key)</span></p></body></div></li><li><blockquote><p>分配一个 coroutine 的内存空间 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=237&y=605&id=79&uuid=5c2da176210ba61efbdbbb6a9918425c>[P9]</a></p></blockquote></li><li><blockquote><p>栈空间，栈大小，初始状态，创建时间，子过程回调函数，子过程的调用参数 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=324&y=628&id=80&uuid=32926d73da0caf6427eb8a9817ea070f>[P9]</a></p></blockquote></li><li><blockquote><p>分配协程添加到就绪队列 ready_queue <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=279&y=652&id=82&uuid=4223222131cd1b8fc59047eeb28e2aae>[P9]</a></p></blockquote></li><li><blockquote><p>pthread_once <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=188&y=731&id=85&uuid=0ac0c8ac0cb5aa2a2aa283676e7a8d4d>[P9]</a></p></blockquote><div class="annot">确保一个函数在多线程环境中只被执行1次</div></li><li><blockquote><p>posix_memalign <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=10&x=211&y=362&id=86&uuid=7b716b26e0e08ae4a27003176a016359>[P10]</a></p></blockquote><div class="annot">对齐内存分配函数</div></li><li><blockquote><p>spawned_coroutines <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=10&x=257&y=533&id=87&uuid=f62b89c1cbb849000a567c32cf6b87b9>[P10]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">int类型：已创建的协程数量</p></body></div></li><li><blockquote><p>yield： 让出 CPU <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=11&x=160&y=81&id=88&uuid=494dc9bf3d5ac06f0bed86936b2df3bd>[P11]</a></p></blockquote><div class="annot">swapcontext(协程, 调度器) → 协程让出，调度器接管</div></li><li><blockquote><p>resume：恢复协程的运行权 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=11&x=185&y=190&id=89&uuid=8958e9d2e05564d19d2f435a52597595>[P11]</a></p></blockquote><div class="annot">swapcontext(调度器, 协程) → 调度器让出，协程接管</div></li><li><blockquote><p>问题：协程的内部原语操作有哪些？分别如何实现的？ <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=9&x=276&y=433&id=90&uuid=b9be09618a00427ad369bb0a5f4f5069>[P9]</a></p></blockquote></li><li><blockquote><p>问题：协程的上下文如何切换？切换代码如何实现？ <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=11&x=232&y=340&id=91&uuid=228b8e937573e81146fbb9571aa8c01c>[P11]</a></p></blockquote></li><li><blockquote><p>上下文切换，就是将 CPU 的寄存器暂时保存，再将即将运行的协程的上下文寄存器，分别mov 到相对应的寄存器上。此时上下文完成切换。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=11&x=298&y=535&id=92&uuid=f6620389394476068ad083e03a26c17a>[P11]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;">从当前正在运行的协程（例如Coroutine A）切换到另一个协程（例如Coroutine B）时：</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;">1. 将CPU中</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; font-weight:600; color:#0f1115; background-color:#ffffff;">所有需要被调用者保存的（callee-saved）寄存器</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;">的值，内存拷贝到Coroutine A自己的</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; font-weight:600; color:#0f1115; background-color:#ffffff;">上下文结构体（struct context）</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;"> 中</span></p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;">2. 从Coroutine B的</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; font-weight:600; color:#0f1115; background-color:#ffffff;">上下文结构体（struct context）</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;"> 中，将之前保存的寄存器值，</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; font-weight:600; color:#0f1115; background-color:#ffffff;">逐一地、精确地</span><span style=" font-family:'quote-cjk-patch','Inter','system-ui','-apple-system','BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Open Sans','Helvetica Neue','sans-serif'; font-size:16px; color:#0f1115; background-color:#ffffff;">写回到CPU的对应寄存器中</span></p></body></div></li><li><blockquote><p>切换_switch 函数 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=12&x=133&y=329&id=93&uuid=11de1ef462a0524e8c3b9bd405d2825e>[P12]</a></p></blockquote></li><li><blockquote><p>x86_64 的寄存器 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=13&x=153&y=439&id=94&uuid=6ce715f52a609f83805eaad9c07dfac1>[P13]</a></p></blockquote><div class="annot">这部分汇编代码的注释没看懂</div></li><li><blockquote><p>问题：协程如何定义? 调度器如何定义？ <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=13&x=240&y=714&id=95&uuid=4fdf012b4899666f07c55d9486a07351>[P13]</a></p></blockquote></li><li><blockquote><p>设计一个协程的运行体 R 与运行体调度器 S 的结构体 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=13&x=249&y=761&id=102&uuid=7cc1cf88da5f5834ca91f86f7221e147>[P13]</a></p></blockquote></li><li><blockquote><p>运行体 R <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=173&y=80&id=103&uuid=85d6ea656b7f836cecfdfe6be1e80dc2>[P14]</a></p></blockquote></li><li><blockquote><p>调度器 S <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=173&y=111&id=104&uuid=653df6ab9d1a2b0de9a11ed4f1447f4c>[P14]</a></p></blockquote></li><li><blockquote><p>运行状态{就绪，睡眠，等待} <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=309&y=80&id=105&uuid=9bca22d0eb9c77adb1499108fdfe4b85>[P14]</a></p></blockquote></li><li><blockquote><p>执行集合{就绪，睡眠，等待} <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=309&y=111&id=106&uuid=3167cd1fcd39b7bfda1228b43f3c2905>[P14]</a></p></blockquote></li><li><blockquote><p>这道设计题拆分两个个问题，一个运行体如何高效地在多种状态集合更换。调度器与运行体的功能界限 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=287&y=134&id=107&uuid=bc71a2acc24f6470e551ec4d5af17726>[P14]</a></p></blockquote></li><li><blockquote><p>运行体如何高效地在多种状态集合更换 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=259&y=179&id=108&uuid=f6194badc62c0995c81c496dd2407b58>[P14]</a></p></blockquote></li><li><blockquote><p>IO 准备就绪，协程开始运行，后续进行 sleep 操作，此时进入到睡眠状态集合 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=296&y=238&id=110&uuid=b22b2be8fddcd82eaaaa4daa4d12c2ac>[P14]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">rbtree：<span style=" font-weight:600;">协程在等待 I/O 时，可能被挂入 sleep 集合</span>，原因：<span style=" font-weight:600;">I/O 等待通常伴随超时机制</span><br />比如 <span style=" font-family:'Courier New';">nty_poll_inner(&amp;fds, 1, 1000)</span>，如果 <span style=" font-family:'Courier New';">epoll_wait</span> 一直没返回，就需要一个 <span style=" font-weight:600;">超时时间</span>。这时候协程会被挂到 <span style=" font-weight:600;">sleep rbtree</span>，调度器会在合适的时机检查并唤醒它（超时或 I/O 就绪）。</p></body></div></li><li><blockquote><p>协程在运行完成后，进行 IO 操作，此时 IO 并未准备好，进入等待状态集合 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=293&y=223&id=111&uuid=97180b45aef60eb6f9087097bfa8f2b6>[P14]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">rbtree：协程在执行 I/O 时，如果底层 <span style=" font-family:'Courier New';">epoll_wait</span> 发现对应的 fd 尚未就绪，就会把协程挂起，记录到 <span style=" font-weight:600;">等待集合</span>，</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">并把 fd 与协程进行映射（相当于“协程自己不忙轮询，而是让 epoll 代理等待事件”）。</p></body></div></li><li><blockquote><p>新创建的协程，创建完成后，加入到就绪集合，等待调度器的调度 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=285&y=215&id=113&uuid=d7061a08252c39fa301beb99be02ff6e>[P14]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">ready queue：新建的协程，或被唤醒的协程，会被放入这里，等待调度器 resume</p></body></div></li><li><blockquote><p>就绪队列（ready_queue） <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=390&y=309&id=114&uuid=ce47657d7029f9d29b4a47e3664ae90f>[P14]</a></p></blockquote></li><li><blockquote><p>就绪(ready) <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=146&y=293&id=115&uuid=71b0377344c000ddbc658a3c3fc12b60>[P14]</a></p></blockquote></li><li><blockquote><p>睡眠(sleep) <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=146&y=324&id=116&uuid=c73181556ee14e2c06de7ce97d50a862>[P14]</a></p></blockquote></li><li><blockquote><p>红黑树 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=402&y=324&id=117&uuid=ed46ea2077850d3bce2e70deb306e146>[P14]</a></p></blockquote></li><li><blockquote><p><key, value>, key 为睡眠时长，value 为对应的协程结点。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=289&y=348&id=118&uuid=7aeda2344a12dc983ff77d041c70b2e6>[P14]</a></p></blockquote></li><li><blockquote><p>等待(wait)集合 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=154&y=371&id=119&uuid=4a68f2a467831a9c66208b66ef4f7b8d>[P14]</a></p></blockquote></li><li><blockquote><p>红黑树 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=242&y=387&id=120&uuid=790164832c2b72fca8f6ba9cbe29f758>[P14]</a></p></blockquote></li><li><blockquote><p>等待 IO 准备就绪，等待 IO 也是有时长的 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=379&y=371&id=122&uuid=f1d764309ab8ffedfe83f3d9c4fb8bf1>[P14]</a></p></blockquote></li><li><blockquote><p>Coroutine 就是协程的相应属性，status 表示协程的运行状态。sleep 与wait 两颗红黑树，ready 使用的队列 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=287&y=723&id=123&uuid=4f58c462a95f60c606998dfc0166f7bb>[P14]</a></p></blockquote></li><li><blockquote><p>比如某协程调用 sleep 函数，加入睡眠树(sleep_tree)，status |= S 即可。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=292&y=738&id=133&uuid=4d66462f4c10bb858d8ada656ec1f04f>[P14]</a></p></blockquote></li><li><blockquote><p>比如某协程在等待树(wait_tree)中，而 IO 准备就绪放入 ready 队列中，只需要移出等待树(wait_tree)，状 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=14&x=293&y=753&id=134&uuid=faad472a144e1c7864827422cde808f5>[P14]</a></p></blockquote></li><li><blockquote><p>态更改 status &= ~W 即可。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=169&y=80&id=135&uuid=4bedbdcf0db9dc300872c5c14b3e01a2>[P15]</a></p></blockquote></li><li><blockquote><p>有一个前提条件就是不管何种运行状态的协程，都在就绪队列中，只是同时包含有其他的运行状态。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=295&y=88&id=136&uuid=1785ae7b0683f9c066c555965a4fdd96>[P15]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">就绪队列是调度的核心容器</span>，协程最终都是通过就绪队列进入调度。</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">即使协程当前是 “IO等待”、“sleep” 等状态，它<span style=" font-weight:600;">也会有一个入口在就绪队列里</span>，只是调度器在调度它时，会检查它的其他状态（比如 sleep 时间没到，或者 epoll 没有事件） → 那么它不会真正被执行，而是会再次挂起。(即其他状态（sleep、wait、done）只是<span style=" font-weight:600;">额外的标记/集合</span>，决定了协程是否能从就绪队列里“真正运行”。)</p></body></div></li><li><blockquote><p>每一协程都需要使用的而且可能会不同属性的，就是协程属性。每一协程都需要的而且数据一致的，就是调度器的属性。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=293&y=192&id=138&uuid=e57152d9e115a13a1ad1dac894fe4f1a>[P15]</a></p></blockquote></li><li><blockquote><p>比如栈大小的数值，每个协程都一样的后不做更改可以作为调度器的属性，如果每个协程大小不一致，则可以作为协程的属性。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=295&y=215&id=139&uuid=636a06eab4af0a3741949c52a89bf7cc>[P15]</a></p></blockquote></li><li><blockquote><p>用来管理所有协程的属性，作为调度器的属性。比如 epoll 用来管理每一个协程对应的 IO，是需要作为调度器属性。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=295&y=254&id=143&uuid=71e3d9f6924eec2ffc5e9fa7d7d212d5>[P15]</a></p></blockquote></li><li><blockquote><p>定义一个协程结构体需要多少域，我们描述了每一个协程有自己的上下文环境，需要保存 CPU 的寄存器 ctx；需要有子过程的回调函数 func；需要有子过程回调函数的参数 arg；需要定义自己的栈空间 stack；需要有自己栈空间的大小 stack_size；需要定义协程的创建时间 birth；需要定义协程当前的运行状态 status；需要定当前运行状态的结点（ready_next, wait_node, sleep_node） ；需要定义协程 id；需要定义调度器的全局对象 sched。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=15&x=293&y=340&id=144&uuid=1359b9f793a36a7a0840372ddad8e1a9>[P15]</a></p></blockquote></li><li><blockquote><p>调度器是管理所有协程运行的组件 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=16&x=180&y=80&id=146&uuid=ed61db83712946c0fcdba0395b1063fa>[P16]</a></p></blockquote></li><li><blockquote><p>从协程到调度器用 yield，从调度器到协程用 resume <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=16&x=360&y=283&id=147&uuid=b7d5eb227919d485cd89848f45fb718e>[P16]</a></p></blockquote></li><li><blockquote><p>保存 CPU 的寄存器上下文 ctx <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=16&x=289&y=267&id=148&uuid=aaef4ae5028f190e030d89b38854f221>[P16]</a></p></blockquote></li><li><blockquote><p>协程的定义 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=16&x=177&y=298&id=149&uuid=3a000e1407d6c3f19a982b2c648a111b>[P16]</a></p></blockquote><div class="annot">协程的定义代码</div></li><li><blockquote><p>问题：协程如何被调度？ <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=17&x=198&y=124&id=150&uuid=ffe153d3e7bdfb3f174d3dafde732c55>[P17]</a></p></blockquote></li><li><blockquote><p>一种是生产者消费者模式，另一种多状态运行。 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=17&x=293&y=163&id=151&uuid=9d7921bac1a288f66a5adf4de26a4287>[P17]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">生产者/消费者模式：TAILQ_ADD(&amp;sched-&gt;ready, expired / wait);</p><br/><p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">多状态运行：resume(expired/ wait)</p></body></div><div class="annot"><img src = "笔记大纲_协程的实现与原理/1b952c6f0918d99e348041627669f2fb.png"></div><div class="annot"><img src = "笔记大纲_协程的实现与原理/ba17b859ccb9f601d8caa1b6ac52e3ec.png"></div><div class="annot"><img src = "笔记大纲_协程的实现与原理/8f04a82791fe4e75bbd9831d5ab9c13f.png"></div></li><li><blockquote><p>TAILQ_ADD(&sched->ready, wait); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=17&x=242&y=681&id=153&uuid=63fb854a3978cbdbd2de095a744c559b>[P17]</a></p></blockquote></li><li><blockquote><p>TAILQ_ADD(&sched->ready, expired); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=17&x=251&y=557&id=154&uuid=35f5a5fe104d00def12553dd60b017aa>[P17]</a></p></blockquote></li><li><blockquote><p>resume(expired); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=18&x=199&y=528&id=155&uuid=97c018fa2bf35ed5a3bd26eeca06f9e9>[P18]</a></p></blockquote></li><li><blockquote><p>resume(wait); <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=18&x=190&y=653&id=156&uuid=d7cad0b9bd9578aaea1d91df24f55449>[P18]</a></p></blockquote></li><li><blockquote><p>7.1 生产者消费者模式 <a href=bookxnotepro://opennote/?nb={def3dbc6-1f29-47e5-93ed-02d942daa376}&book=7ab762230a8913c8e05d1e844283a2e0&page=17&x=191&y=207&id=158&uuid=cbb89a398774bf6495ddc0aa5e02503d>[P17]</a></p></blockquote><div class="annot"><body style=" font-family:'Microsoft YaHei UI'; font-size:9pt; font-weight:400; font-style:normal;"><br/><p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">NtyCo 的实现就是 <span style=" font-weight:600;">生产者/消费者模式</span>：</p><br/><ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">生产者</span>：各种事件（定时器、IO 就绪、用户调用 <span style=" font-family:'Courier New';">yield</span>），会把协程丢到 ready 队列；</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-weight:600;">消费者</span>：调度器循环，从 ready 队列里取协程，resume 执行；</li><br/><li style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">因此不会出现“事件一发生就直接 resume”，而是排队等待。</li></ul></body></div></li></ul>
<footer><div style = "background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div>
<div style = "text-align:center; "><a target="_blank" href="http://www.bookxnote.com">&copy2018-2024 BookxNote</a></div></footer>
</body>
</html>
